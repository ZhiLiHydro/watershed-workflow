
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Watershed Workflow &#8212; Watershed Workflow 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="watershed-workflow">
<h1>Watershed Workflow<a class="headerlink" href="#watershed-workflow" title="Permalink to this headline">¶</a></h1>
<img alt="_images/watershed_workflow.png" src="_images/watershed_workflow.png" />
<div class="toctree-wrapper compound">
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
<p>Watershed Workflow is a python-based, open source chain of tools for generating meshes and other data inputs for hyper-resolution hydrology, anywhere in the (conterminous + Alaska?) US.</p>
<p>Hyper-resolution hydrologic models have huge data requirements, thanks to their large extent (full river basins) and very high resolution (often ~10-100 meters).  Furthermore, most process-rich models of integrated, distributed hydrology at this scale require meshes that understand both surface land cover and subsurface structure.  Typical data needs for simulations such as these include:</p>
<ul class="simple">
<li><p>Watershed delineation (what is your domain?)</p></li>
<li><p>Hydrography data (river network geometry, hydrographs for model evaluation)</p></li>
<li><p>A digital elevation model (DEM) for surface topography</p></li>
<li><p>Surface land use / land cover</p></li>
<li><p>Subsurface soil types and properties</p></li>
<li><p>Meterological data,</p></li>
</ul>
<p>and more.</p>
<p>This package is a python library of tools and a set of jupyter notebooks for interacting with these types of data streams using free and open (both free as in freedom and free as in free beer) python and GIS libraries and data.  Critically, this package provides a way for <strong>automatically and quickly</strong> downloading, interpreting, and processing data needed to <strong>generate a “first” hyper-resolution simulation on any watershed</strong> in the conterminous United States (and most of Alaska/Hawaii/Puerto Rico).</p>
<p>To do this, this package provides tools to automate downloading a wide range of <strong>open data streams,</strong> including data from United States governmental agencies, including USGS, USDA, DOE, and others.  These data streams are then colocated on a mesh which is generated based on a watershed delineation and a river network, and that mesh is written in one of a variety of mesh formats for use in hyper-resolution simulation tools.</p>
<p>Note: Hypothetically, this package works on all of Linux, Mac, and Windows.  It has been tested on the first two, but not the third.</p>
</div>
<div class="section" id="installation-and-setup">
<h2>Installation and Setup<a class="headerlink" href="#installation-and-setup" title="Permalink to this headline">¶</a></h2>
<p>All code is in python3, though the dependencies (because of their need for GIS libraries) can be tricky to get right.  It is recommended to use Anaconda3 as a package manager, generating a unique environment for use with this package, as this makes it fairly easy to get all the required packages.</p>
<p>Note that this package is not currently installed in a typical pythononic way (i.e. setuptools), but instead expects you to simply use it in place.  This will change shortly.  In the meantime, to install this package, simply place it in your python path:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">export PYTHONPATH=/path/to/watershed-workflow:${PYTHONPATH}</span>
</pre></div>
</div>
<div class="section" id="dependencies">
<h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<dl class="simple">
<dt>Standard packages needed include <cite>argparse</cite> and <cite>subprocess</cite>, and for testing, <cite>pytest</cite> and <cite>dist_utils</cite>.</dt><dd><p>Standard math packages include <cite>numpy</cite>, <cite>matplotlib</cite>, and <cite>scipy</cite>.</p>
</dd>
</dl>
<p>GIS work is typically done using expensive/closed source and GUI-based tools.  For this work, we instead build on the extremely high-quality, open-source packages for GIS in python: <cite>fiona</cite>, <cite>rasterio</cite>, <cite>shapely</cite> and <cite>cartopy</cite>.</p>
<p>Mesh generation of 2D, “map view” surface meshes uses the open source library Triangle, which can be wrapped for python using <cite>meshpy</cite>.  This in turn depends upon boost python.  Optionally, extrusion of this 2D mesh into a 3D mesh for use in integrated hydrologic models requires a 3D mesh library ~~ we tend to use ExodusII here (though it would be straightforward to extend this to other packages such as VTK).  ExodusII, part of the <a class="reference external" href="https://github.com/gsjaardema/seacas">SEACAS</a> suite of tools, provides a python3 set of wrappers, but there is no current package, so this must be installed separately.  See below.</p>
</div>
<div class="section" id="recommended-process">
<h3>Recommended process<a class="headerlink" href="#recommended-process" title="Permalink to this headline">¶</a></h3>
<p>Download and install <a class="reference external" href="https://www.anaconda.com/distribution/">Anaconda3</a>.  Then create a new environment that includes the required packages:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">conda create -n ats_meshing -c conda-forge -c defaults python=3 ipython numpy matplotlib scipy meshpy fiona rasterio shapely cartopy descartes ipykernel requests sortedcontainers attrs pytest</span>
<span class="go">conda activate ats_meshing</span>
</pre></div>
</div>
<p>Check your python installation:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">python -c &#39;import numpy, matplotlib, scipy, rasterio, fiona, shapely, cartopy, meshpy.triangle; print(&quot;SUCCESS&quot;)&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="installing-exodusii-optional">
<h3>Installing ExodusII (optional)<a class="headerlink" href="#installing-exodusii-optional" title="Permalink to this headline">¶</a></h3>
<p>Clone the package from <a class="reference external" href="https://github.com/gsjaardema/seacas">source</a></p>
<p>Unfortunately this package does not do regular releases except as part of the Trilinos project, and those releases are often somewhat old.  Then, edit the script at <cite>workflow_tpls/configure-seacas.sh</cite> &lt;../master/workflow_tpls/configure-seacas.sh&gt;`_, defining your compilers (likely clang if Mac and gcc if Linux) and pointing to your SEACAS repo and Anaconda environment installation.</p>
<p>Hopefully you are then able to add your installed SEACAS to your PYTHONPATH and import the python wrappers:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">export PYTHONPATH=${SEACAS_DIR}/lib</span>
<span class="go">python -c &#39;import exodus; print(&quot;SUCCESS&quot;)&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="setting-up-your-environment">
<h3>Setting up your environment<a class="headerlink" href="#setting-up-your-environment" title="Permalink to this headline">¶</a></h3>
<p>Once all of the above work and are installed, setting up the environment from scratch consists of the following:</p>
<blockquote>
<div><p>conda activate ats_meshing
export PYTHONPATH=/path/to/watershed-workflow:/path/to/SEACAS/install/lib:${PYTHONPATH}</p>
</div></blockquote>
</div>
</div>
<div class="section" id="a-first-example">
<h2>A first example<a class="headerlink" href="#a-first-example" title="Permalink to this headline">¶</a></h2>
<p>A good way to get started is to open your jupyter notebook and check out the main workflow:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">jupyter notebook</span>
</pre></div>
</div>
<p>And navigate to <a class="reference external" href="../master/examples/mesh_coweeta.ipynb">examples/mesh_coweeta.ipynb</a></p>
</div>
<div class="section" id="funding-attribution-etc">
<h2>Funding, attribution, etc<a class="headerlink" href="#funding-attribution-etc" title="Permalink to this headline">¶</a></h2>
<p>This work was supported by multiple US Department of Energy projects, largely by Ethan Coon (coonet _at_ ornl _dot_ gov) at the Oak Ridge National Laboratory.  Use of this codebase in the academic literature should cite this repository (paper in preparation).</p>
<p>Collaborators and contributions are very welcome!</p>
</div>
<div class="section" id="workflow-library-concepts">
<h2>Workflow library Concepts<a class="headerlink" href="#workflow-library-concepts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="crs">
<h3>CRS<a class="headerlink" href="#crs" title="Permalink to this headline">¶</a></h3>
<p>TODO: CRS are everywhere, we use Fiona’s EPSG versions.</p>
</div>
<div class="section" id="shapes-vs-shapely">
<h3>shapes vs shapely<a class="headerlink" href="#shapes-vs-shapely" title="Permalink to this headline">¶</a></h3>
<p>TODO: fiona shapes vs shapely shapes</p>
</div>
<div class="section" id="working-with-data-sources">
<h3>Working with data sources<a class="headerlink" href="#working-with-data-sources" title="Permalink to this headline">¶</a></h3>
<p>TODO: using data sources</p>
</div>
</div>
<div class="section" id="jupyter-workflows-and-examples">
<h2>Jupyter workflows and Examples<a class="headerlink" href="#jupyter-workflows-and-examples" title="Permalink to this headline">¶</a></h2>
<p>Example 1: Generate a mesh</p>
<div class="section" id="watershed-workflow-executables">
<h3>Watershed Workflow executables<a class="headerlink" href="#watershed-workflow-executables" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Example 1: plot_huc.py</p></li>
<li><p>Example 2: plot_shape.py</p></li>
<li><p>Example 3: mesh_huc.py</p></li>
<li><p>Example 4: mesh_shape.py</p></li>
</ul>
</div>
<div class="section" id="module-workflow.hilev">
<span id="workflow-high-level-api"></span><h3>workflow high level API<a class="headerlink" href="#module-workflow.hilev" title="Permalink to this headline">¶</a></h3>
<p>High-level routines for downloading/opening datasets and forming
internal data structures.</p>
<p>Most scripts use these functions instead of directly using lower-level
capability.</p>
<dl class="function">
<dt id="workflow.hilev.get_huc">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_huc</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">huc</em>, <em class="sig-param">crs=None</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_huc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_huc" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a HUC shape object from a given code.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>source object providing <cite>get_hucs()</cite></p>
</dd>
<dt><strong>huc</strong><span class="classifier">str</span></dt><dd><p>hydrologic unit code</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output coordinate system.  Default is source’s crs.</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>Number of digits to round coordinates to.  Default set by config file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></dt><dd><p>Output coordinate system.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Polygon</span></code></dt><dd><p>shapely polygon for the hydrologic unit.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.get_hucs">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_hucs</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">huc</em>, <em class="sig-param">level</em>, <em class="sig-param">crs=None</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_hucs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_hucs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of shape objects for all HUCs at level contained in huc.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>source object providing <cite>get_hucs()</cite></p>
</dd>
<dt><strong>huc</strong><span class="classifier">str</span></dt><dd><p>hydrologic unit code</p>
</dd>
<dt><strong>level</strong><span class="classifier">int</span></dt><dd><p>HUC level of the requested sub-basins</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output coordinate system.  Default is source’s crs.</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>Number of digits to round coordinates to.  Default set by config file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></dt><dd><p>Output coordinate system.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">list(Polygon)</span></code></dt><dd><p>List of shapely polygons for the subbasins.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.get_split_form_hucs">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_split_form_hucs</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">huc</em>, <em class="sig-param">level=None</em>, <em class="sig-param">crs=None</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_split_form_hucs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_split_form_hucs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a SplitHUCs object for all HUCs at level contained in huc.</p>
<p>A <code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitHUCs</span></code> object is an object which stores a collection
of polygons which share boundaries in a format that makes changing
those shared boundaries possible without having to update all
shapes that share the boundary.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>source object providing <cite>get_hucs()</cite></p>
</dd>
<dt><strong>huc</strong><span class="classifier">str</span></dt><dd><p>hydrologic unit code</p>
</dd>
<dt><strong>level</strong><span class="classifier">int</span></dt><dd><p>HUC level of the requested sub-basins</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output coordinate system.  Default is source’s crs.</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>Number of digits to round coordinates to.  Default set by config file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></dt><dd><p>Output coordinate system.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitHUCs</span></code></dt><dd><p>Split-form HUCs object containing subbasins.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.get_shapes">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_shapes</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">index_or_bounds=-1</em>, <em class="sig-param">crs=None</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_shapes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a shapefile.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier">str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>Filename to parse, or a source object providing the get_shapes() method.</p>
</dd>
<dt><strong>index_or_bounds</strong><span class="classifier">int or <code class="xref py py-obj docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">ymin,</span> <span class="pre">xmax,</span> <span class="pre">ymax]</span></code></span></dt><dd><p>Index of the requested shape in filename, or bounding box to filter shapes, 
or -1 to get them all.</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output coordinate system.  Default is source’s crs.</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>Number of digits to round coordinates to.  Default set by config file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></dt><dd><p>Output coordinate system.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">list(Polygon)</span></code></dt><dd><p>List of shapely polygons in the shapefile meeting the criteria.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.get_split_form_shapes">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_split_form_shapes</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">index_or_bounds=-1</em>, <em class="sig-param">crs=None</em>, <em class="sig-param">digits=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_split_form_shapes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_split_form_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a shapefile.</p>
<p>Note: if index_or_bounds is a bounding box, crs must not be None
and is the crs of the bounding box.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier">str or <code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>Filename to parse, or a source object providing the get_shapes() method.</p>
</dd>
<dt><strong>index_or_bounds</strong><span class="classifier">int or <code class="xref py py-obj docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">ymin,</span> <span class="pre">xmax,</span> <span class="pre">ymax]</span></code></span></dt><dd><p>Index of the requested shape in filename, or bounding box to filter shapes, 
or -1 to get them all.</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output coordinate system.  Default is source’s crs.</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>Number of digits to round coordinates to.  Default set by config file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></dt><dd><p>Output coordinate system.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitHUCs</span></code></dt><dd><p>Split-form polygon objects from the shapefile meeting the criteria.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.get_reaches">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_reaches</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">huc</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">crs=None</em>, <em class="sig-param">digits=None</em>, <em class="sig-param">long=None</em>, <em class="sig-param">merge=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_reaches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_reaches" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of reaches from hydrography data within a given HUC and/or bounding box.</p>
<p>Collects reach datasets within a HUC and/or a bounding box.  If bounds are provided,
a containing HUC must still be provided to give a hint for file downloads.  If bounds
are not provided, then all reaches that intersect the HUC are included.</p>
<p>If bounds is provided, crs must not be None and is the crs of the bounding box.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>Source object providing <cite>get_hydro()</cite>.</p>
</dd>
<dt><strong>huc</strong><span class="classifier">str</span></dt><dd><p>Search domain for reaches.  If bounds are provided, a hint to help the source
find the file containing the bounds.  For NHD, this is a HUC4 or smaller.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">ymin,</span> <span class="pre">xmax,</span> <span class="pre">ymax]</span></code></span></dt><dd><p>Bounding box to filter the river network.</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output coordinate system and coordinate system of bounds.  Defaults to the
source’s crs.</p>
</dd>
<dt><strong>digits</strong><span class="classifier">int</span></dt><dd><p>Number of digits to round coordinates to.  Default set by config file.</p>
</dd>
<dt><strong>long</strong><span class="classifier">float</span></dt><dd><p>If a reach is longer than this value it gets filtered.  Some NHD data
has QC issues, or other wierd reaches that don’t make sense…</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></dt><dd><p>Output coordinate system.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">list(LineString)</span></code></dt><dd><p>A list of shapely LineString objects representing all reaches within 
the shape.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.get_raster_on_shape">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_raster_on_shape</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">shape</em>, <em class="sig-param">crs</em>, <em class="sig-param">raster_crs=None</em>, <em class="sig-param">buffer=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_raster_on_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_raster_on_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects a raster DEM that covers the requested shape.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>Source object providing <cite>get_raster()</cite></p>
</dd>
<dt><strong>shape</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Polygon</span></code></span></dt><dd><p>shapely or fiona polygon</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Shape coordinate system</p>
</dd>
<dt><strong>raster_crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output crs.  Defaults to the source’s crs.</p>
</dd>
<dt><strong>buffer</strong><span class="classifier">double</span></dt><dd><p>Size of buffer added to shape to ensure pixels cover the 
entire shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>profile</strong><span class="classifier">dict</span></dt><dd><p>Rasterio profile of the image including crs and transform</p>
</dd>
<dt><strong>raster</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>The raster array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.get_masked_raster_on_shape">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">get_masked_raster_on_shape</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">shape</em>, <em class="sig-param">crs</em>, <em class="sig-param">nodata=-1</em>, <em class="sig-param">buffer=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#get_masked_raster_on_shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.get_masked_raster_on_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Collects a raster DEM that covers the requested shape, masked with 
nodata value outside of the shape.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>Source object providing <cite>get_raster()</cite></p>
</dd>
<dt><strong>shape</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Polygon</span></code></span></dt><dd><p>shapely or fiona polygon</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Output and shape coordinate system</p>
</dd>
<dt><strong>nodata</strong><span class="classifier">type of raster data</span></dt><dd><p>Value placed outside of shape.</p>
</dd>
<dt><strong>buffer</strong><span class="classifier">double</span></dt><dd><p>Size of buffer added to shape to ensure pixels cover the 
entire shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>dem_profile</strong><span class="classifier">dict</span></dt><dd><p>Rasterio profile of the image including crs and transform</p>
</dd>
<dt><strong>dem</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">np.array</span></code></span></dt><dd><p>The raster array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.find_huc">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">find_huc</code><span class="sig-paren">(</span><em class="sig-param">source</em>, <em class="sig-param">shape</em>, <em class="sig-param">crs</em>, <em class="sig-param">hint</em>, <em class="sig-param">shrink_factor=1e-05</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#find_huc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.find_huc" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the smallest HUC containing shp.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>source</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">source-type</span></code></span></dt><dd><p>Source object providing <cite>get_hucs()</cite></p>
</dd>
<dt><strong>shape</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Polygon</span></code></span></dt><dd><p>shapely or fiona polygon</p>
</dd>
<dt><strong>crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>shape coordinate system</p>
</dd>
<dt><strong>hint</strong><span class="classifier">str</span></dt><dd><p>A HUC hint for where to look, must be at least as small as 
the source’s organizational file – 2 for source WBD, 4 
for NHDPlus.</p>
</dd>
<dt><strong>shrink_factor</strong><span class="classifier">float</span></dt><dd><p>A fraction of the radius of shape to shrink prior for 
checking containment within HUCs.  This fixes cases where 
shape is on a HUC boundary with potentially some numerical 
error.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>str</strong><span class="classifier">The smallest containing HUC.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.simplify_and_prune">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">simplify_and_prune</code><span class="sig-paren">(</span><em class="sig-param">hucs</em>, <em class="sig-param">reaches</em>, <em class="sig-param">simplify=10</em>, <em class="sig-param">prune_reach_size=0</em>, <em class="sig-param">cut_intersections=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#simplify_and_prune"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.simplify_and_prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleans up the HUC and river shapes.</p>
<p>Ensures intersections are proper, snapped, simplified, etc.  Note,
HUCs and rivers must be in the same crs.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>hucs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitHUCs</span></code></span></dt><dd><p>The split-form HUC object from get_split_form_hucs()</p>
</dd>
<dt><strong>reaches</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list(LineString)</span></code></span></dt><dd><p>The list of reaches from get_reaches()</p>
</dd>
<dt><strong>simplify</strong><span class="classifier">float</span></dt><dd><p>Argument to shapely’s simplify, a measure of how far to allow 
shapes to move.  Default is 10 (units are in crs)</p>
</dd>
<dt><strong>prune_river_size</strong><span class="classifier">int</span></dt><dd><p>Remove rivers with fewer than this number of reaches.  Default 
is 0.</p>
</dd>
<dt><strong>cut_intersections</strong><span class="classifier">bool</span></dt><dd><p>Cut HUC segments at the river input/output, potentially resulting
in simpler geometries.  This is work in progress.  Default is 
False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>:obj:`list(Tree)`</strong><span class="classifier">A list of rivers, as Tree objects.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.triangulate">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">triangulate</code><span class="sig-paren">(</span><em class="sig-param">hucs</em>, <em class="sig-param">rivers</em>, <em class="sig-param">diagnostics=True</em>, <em class="sig-param">verbosity=1</em>, <em class="sig-param">refine_max_area=None</em>, <em class="sig-param">refine_distance=None</em>, <em class="sig-param">refine_max_edge_length=None</em>, <em class="sig-param">refine_min_angle=None</em>, <em class="sig-param">enforce_delaunay=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#triangulate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Triangulates HUCs and rivers.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>hucs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SplitHUCs</span></code></span></dt><dd><p>The split-form HUC object from get_split_form_hucs()</p>
</dd>
<dt><strong>reaches</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list(LineString)</span></code></span></dt><dd><p>The list of reaches from get_reaches()</p>
</dd>
<dt><strong>diagnostics</strong><span class="classifier">bool</span></dt><dd><p>Plot diagnostics graphs of the triangle refinement.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>np.array((n_points, 2), ‘d’)</dt><dd><p>Array of triangle vertices.</p>
</dd>
<dt>np.array((n_tris, 3), ‘i’)</dt><dd><p>For each triangle, a list of 3 indices into the vertex
array that make up that triangle.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.elevate">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">elevate</code><span class="sig-paren">(</span><em class="sig-param">mesh_points</em>, <em class="sig-param">mesh_crs</em>, <em class="sig-param">dem</em>, <em class="sig-param">dem_profile</em>, <em class="sig-param">algorithm='piecewise bilinear'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#elevate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.elevate" title="Permalink to this definition">¶</a></dt>
<dd><p>Elevate mesh_points onto the provided dem.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>mesh_points</strong><span class="classifier">np.array((n_points, 2), ‘d’)</span></dt><dd><p>Array of triangle vertices.</p>
</dd>
<dt><strong>mesh_crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Mesh coordinate system.</p>
</dd>
<dt><strong>dem</strong><span class="classifier">np.array</span></dt><dd><p>2D array forming an elevation raster.</p>
</dd>
<dt><strong>dem_profile</strong><span class="classifier">dict</span></dt><dd><p>rasterio profile for the elevation raster.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">str</span></dt><dd><p>Algorithm used for interpolation.  One of:
* “nearest”
* “piecewise bilinear”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>np.array((n_points, 3), ‘d’)</dt><dd><p>Array of triangle vertices, including a z-dimension.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.values_from_raster">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">values_from_raster</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">points_crs</em>, <em class="sig-param">raster</em>, <em class="sig-param">raster_profile</em>, <em class="sig-param">algorithm='nearest'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#values_from_raster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.values_from_raster" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a raster onto a collection of unstructured points.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>points</strong><span class="classifier">np.array((n_points, 2), ‘d’)</span></dt><dd><p>Array of points to interpolate onto.</p>
</dd>
<dt><strong>points_crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Coordinate system of the points.</p>
</dd>
<dt><strong>raster</strong><span class="classifier">np.array</span></dt><dd><p>2D array forming the raster.</p>
</dd>
<dt><strong>raster_profile</strong><span class="classifier">dict</span></dt><dd><p>rasterio profile for the raster.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">str</span></dt><dd><p>Algorithm used for interpolation.  One of:
* “nearest”
* “piecewise bilinear”</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>np.array((n_points,))</dt><dd><p>Array of raster values interpolated onto the points.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="workflow.hilev.color_raster_from_shapes">
<code class="sig-prename descclassname">workflow.hilev.</code><code class="sig-name descname">color_raster_from_shapes</code><span class="sig-paren">(</span><em class="sig-param">target_bounds</em>, <em class="sig-param">target_dx</em>, <em class="sig-param">shapes</em>, <em class="sig-param">shape_colors</em>, <em class="sig-param">shapes_crs</em>, <em class="sig-param">nodata=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/workflow/hilev.html#color_raster_from_shapes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#workflow.hilev.color_raster_from_shapes" title="Permalink to this definition">¶</a></dt>
<dd><p>Color in a raster by filling in a collection of shapes.</p>
<p>Given a canvas specified by bounds and pixel size, color
a raster by, for each shape, finding the intersection of 
that shape with the canvas and coloring it by a provided
value.  Paint by numbers.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>target_bounds</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">ymin,</span> <span class="pre">xmax,</span> <span class="pre">ymax]</span></code></span></dt><dd><p>Bounding box for the output raster.</p>
</dd>
<dt><strong>target_dx</strong><span class="classifier">float</span></dt><dd><p>Pixel size (assumed the same in both x and y).</p>
</dd>
<dt><strong>shapes</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">list(Polygon)</span></code></span></dt><dd><p>Collection of shapes (likely) overlapping the canvas.</p>
</dd>
<dt><strong>shapes_colors</strong><span class="classifier">np.array((n_shapes,), dtype)</span></dt><dd><p>Color to label the interior of each polygon with.</p>
</dd>
<dt><strong>shapes_crs</strong><span class="classifier"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crs</span></code></span></dt><dd><p>Coordinate system of the shapes.</p>
</dd>
<dt><strong>nodata</strong><span class="classifier">dtype</span></dt><dd><p>Value to place in pixels which intersect no shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>np.array(target_bounds, dtype)</dt><dd><p>Raster of colors.</p>
</dd>
<dt>dict</dt><dd><p>rasterio profile of the color raster.</p>
</dd>
<dt>bounds</dt><dd><p>bounds of the resulting image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-workflow.utils">
<span id="workflow-utils-api"></span><h3>workflow utils API<a class="headerlink" href="#module-workflow.utils" title="Permalink to this headline">¶</a></h3>
<p>Shape utilities not provided by shapely.</p>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">Watershed Workflow</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Ethan Coon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>